// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/bobacgo/ai-shop/user/internal/repo/model"
)

func newUserLoginSuccessLog(db *gorm.DB, opts ...gen.DOOption) userLoginSuccessLog {
	_userLoginSuccessLog := userLoginSuccessLog{}

	_userLoginSuccessLog.userLoginSuccessLogDo.UseDB(db, opts...)
	_userLoginSuccessLog.userLoginSuccessLogDo.UseModel(&model.UserLoginSuccessLog{})

	tableName := _userLoginSuccessLog.userLoginSuccessLogDo.TableName()
	_userLoginSuccessLog.ALL = field.NewAsterisk(tableName)
	_userLoginSuccessLog.ID = field.NewUint64(tableName, "id")
	_userLoginSuccessLog.UserID = field.NewString(tableName, "user_id")
	_userLoginSuccessLog.Username = field.NewString(tableName, "username")
	_userLoginSuccessLog.LoginTime = field.NewTime(tableName, "login_time")
	_userLoginSuccessLog.ClientIP = field.NewString(tableName, "client_ip")
	_userLoginSuccessLog.UserAgent = field.NewString(tableName, "user_agent")
	_userLoginSuccessLog.LoginChannel = field.NewUint32(tableName, "login_channel")
	_userLoginSuccessLog.GeoLocation = field.NewString(tableName, "geo_location")
	_userLoginSuccessLog.AuthMethod = field.NewString(tableName, "auth_method")
	_userLoginSuccessLog.DeviceFingerprint = field.NewString(tableName, "device_fingerprint")
	_userLoginSuccessLog.RiskLevel = field.NewInt32(tableName, "risk_level")

	_userLoginSuccessLog.fillFieldMap()

	return _userLoginSuccessLog
}

// userLoginSuccessLog 用户登录成功日志表
type userLoginSuccessLog struct {
	userLoginSuccessLogDo userLoginSuccessLogDo

	ALL               field.Asterisk
	ID                field.Uint64 // 日志主键
	UserID            field.String // 用户ID
	Username          field.String // 登录用户名
	LoginTime         field.Time   // 登录时间(含毫秒)
	ClientIP          field.String // 客户端IP(支持IPv6)
	UserAgent         field.String // 浏览器UA原始值
	LoginChannel      field.Uint32 // 登录渠道(0=Web,1=Android,...)
	GeoLocation       field.String // 地理定位(格式：国家-省份-城市)
	AuthMethod        field.String // 认证方式
	DeviceFingerprint field.String // 设备指纹MD5
	RiskLevel         field.Int32  // 风险等级(0=正常,1=可疑,2=高危)

	fieldMap map[string]field.Expr
}

func (u userLoginSuccessLog) Table(newTableName string) *userLoginSuccessLog {
	u.userLoginSuccessLogDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u userLoginSuccessLog) As(alias string) *userLoginSuccessLog {
	u.userLoginSuccessLogDo.DO = *(u.userLoginSuccessLogDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *userLoginSuccessLog) updateTableName(table string) *userLoginSuccessLog {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewUint64(table, "id")
	u.UserID = field.NewString(table, "user_id")
	u.Username = field.NewString(table, "username")
	u.LoginTime = field.NewTime(table, "login_time")
	u.ClientIP = field.NewString(table, "client_ip")
	u.UserAgent = field.NewString(table, "user_agent")
	u.LoginChannel = field.NewUint32(table, "login_channel")
	u.GeoLocation = field.NewString(table, "geo_location")
	u.AuthMethod = field.NewString(table, "auth_method")
	u.DeviceFingerprint = field.NewString(table, "device_fingerprint")
	u.RiskLevel = field.NewInt32(table, "risk_level")

	u.fillFieldMap()

	return u
}

func (u *userLoginSuccessLog) WithContext(ctx context.Context) IUserLoginSuccessLogDo {
	return u.userLoginSuccessLogDo.WithContext(ctx)
}

func (u userLoginSuccessLog) TableName() string { return u.userLoginSuccessLogDo.TableName() }

func (u userLoginSuccessLog) Alias() string { return u.userLoginSuccessLogDo.Alias() }

func (u userLoginSuccessLog) Columns(cols ...field.Expr) gen.Columns {
	return u.userLoginSuccessLogDo.Columns(cols...)
}

func (u *userLoginSuccessLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *userLoginSuccessLog) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 11)
	u.fieldMap["id"] = u.ID
	u.fieldMap["user_id"] = u.UserID
	u.fieldMap["username"] = u.Username
	u.fieldMap["login_time"] = u.LoginTime
	u.fieldMap["client_ip"] = u.ClientIP
	u.fieldMap["user_agent"] = u.UserAgent
	u.fieldMap["login_channel"] = u.LoginChannel
	u.fieldMap["geo_location"] = u.GeoLocation
	u.fieldMap["auth_method"] = u.AuthMethod
	u.fieldMap["device_fingerprint"] = u.DeviceFingerprint
	u.fieldMap["risk_level"] = u.RiskLevel
}

func (u userLoginSuccessLog) clone(db *gorm.DB) userLoginSuccessLog {
	u.userLoginSuccessLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u userLoginSuccessLog) replaceDB(db *gorm.DB) userLoginSuccessLog {
	u.userLoginSuccessLogDo.ReplaceDB(db)
	return u
}

type userLoginSuccessLogDo struct{ gen.DO }

type IUserLoginSuccessLogDo interface {
	gen.SubQuery
	Debug() IUserLoginSuccessLogDo
	WithContext(ctx context.Context) IUserLoginSuccessLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserLoginSuccessLogDo
	WriteDB() IUserLoginSuccessLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserLoginSuccessLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserLoginSuccessLogDo
	Not(conds ...gen.Condition) IUserLoginSuccessLogDo
	Or(conds ...gen.Condition) IUserLoginSuccessLogDo
	Select(conds ...field.Expr) IUserLoginSuccessLogDo
	Where(conds ...gen.Condition) IUserLoginSuccessLogDo
	Order(conds ...field.Expr) IUserLoginSuccessLogDo
	Distinct(cols ...field.Expr) IUserLoginSuccessLogDo
	Omit(cols ...field.Expr) IUserLoginSuccessLogDo
	Join(table schema.Tabler, on ...field.Expr) IUserLoginSuccessLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserLoginSuccessLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserLoginSuccessLogDo
	Group(cols ...field.Expr) IUserLoginSuccessLogDo
	Having(conds ...gen.Condition) IUserLoginSuccessLogDo
	Limit(limit int) IUserLoginSuccessLogDo
	Offset(offset int) IUserLoginSuccessLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserLoginSuccessLogDo
	Unscoped() IUserLoginSuccessLogDo
	Create(values ...*model.UserLoginSuccessLog) error
	CreateInBatches(values []*model.UserLoginSuccessLog, batchSize int) error
	Save(values ...*model.UserLoginSuccessLog) error
	First() (*model.UserLoginSuccessLog, error)
	Take() (*model.UserLoginSuccessLog, error)
	Last() (*model.UserLoginSuccessLog, error)
	Find() ([]*model.UserLoginSuccessLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserLoginSuccessLog, err error)
	FindInBatches(result *[]*model.UserLoginSuccessLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.UserLoginSuccessLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserLoginSuccessLogDo
	Assign(attrs ...field.AssignExpr) IUserLoginSuccessLogDo
	Joins(fields ...field.RelationField) IUserLoginSuccessLogDo
	Preload(fields ...field.RelationField) IUserLoginSuccessLogDo
	FirstOrInit() (*model.UserLoginSuccessLog, error)
	FirstOrCreate() (*model.UserLoginSuccessLog, error)
	FindByPage(offset int, limit int) (result []*model.UserLoginSuccessLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserLoginSuccessLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userLoginSuccessLogDo) Debug() IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Debug())
}

func (u userLoginSuccessLogDo) WithContext(ctx context.Context) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userLoginSuccessLogDo) ReadDB() IUserLoginSuccessLogDo {
	return u.Clauses(dbresolver.Read)
}

func (u userLoginSuccessLogDo) WriteDB() IUserLoginSuccessLogDo {
	return u.Clauses(dbresolver.Write)
}

func (u userLoginSuccessLogDo) Session(config *gorm.Session) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Session(config))
}

func (u userLoginSuccessLogDo) Clauses(conds ...clause.Expression) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userLoginSuccessLogDo) Returning(value interface{}, columns ...string) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userLoginSuccessLogDo) Not(conds ...gen.Condition) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userLoginSuccessLogDo) Or(conds ...gen.Condition) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userLoginSuccessLogDo) Select(conds ...field.Expr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userLoginSuccessLogDo) Where(conds ...gen.Condition) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userLoginSuccessLogDo) Order(conds ...field.Expr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userLoginSuccessLogDo) Distinct(cols ...field.Expr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userLoginSuccessLogDo) Omit(cols ...field.Expr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userLoginSuccessLogDo) Join(table schema.Tabler, on ...field.Expr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userLoginSuccessLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userLoginSuccessLogDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userLoginSuccessLogDo) Group(cols ...field.Expr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userLoginSuccessLogDo) Having(conds ...gen.Condition) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userLoginSuccessLogDo) Limit(limit int) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userLoginSuccessLogDo) Offset(offset int) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userLoginSuccessLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userLoginSuccessLogDo) Unscoped() IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userLoginSuccessLogDo) Create(values ...*model.UserLoginSuccessLog) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userLoginSuccessLogDo) CreateInBatches(values []*model.UserLoginSuccessLog, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userLoginSuccessLogDo) Save(values ...*model.UserLoginSuccessLog) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userLoginSuccessLogDo) First() (*model.UserLoginSuccessLog, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserLoginSuccessLog), nil
	}
}

func (u userLoginSuccessLogDo) Take() (*model.UserLoginSuccessLog, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserLoginSuccessLog), nil
	}
}

func (u userLoginSuccessLogDo) Last() (*model.UserLoginSuccessLog, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserLoginSuccessLog), nil
	}
}

func (u userLoginSuccessLogDo) Find() ([]*model.UserLoginSuccessLog, error) {
	result, err := u.DO.Find()
	return result.([]*model.UserLoginSuccessLog), err
}

func (u userLoginSuccessLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.UserLoginSuccessLog, err error) {
	buf := make([]*model.UserLoginSuccessLog, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userLoginSuccessLogDo) FindInBatches(result *[]*model.UserLoginSuccessLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userLoginSuccessLogDo) Attrs(attrs ...field.AssignExpr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userLoginSuccessLogDo) Assign(attrs ...field.AssignExpr) IUserLoginSuccessLogDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userLoginSuccessLogDo) Joins(fields ...field.RelationField) IUserLoginSuccessLogDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userLoginSuccessLogDo) Preload(fields ...field.RelationField) IUserLoginSuccessLogDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userLoginSuccessLogDo) FirstOrInit() (*model.UserLoginSuccessLog, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserLoginSuccessLog), nil
	}
}

func (u userLoginSuccessLogDo) FirstOrCreate() (*model.UserLoginSuccessLog, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.UserLoginSuccessLog), nil
	}
}

func (u userLoginSuccessLogDo) FindByPage(offset int, limit int) (result []*model.UserLoginSuccessLog, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userLoginSuccessLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userLoginSuccessLogDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userLoginSuccessLogDo) Delete(models ...*model.UserLoginSuccessLog) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userLoginSuccessLogDo) withDO(do gen.Dao) *userLoginSuccessLogDo {
	u.DO = *do.(*gen.DO)
	return u
}
