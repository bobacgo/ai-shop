package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

const templateText = `// Code generated by error message generator. DO NOT EDIT.

package {{ .Package }}

import (
	"context"

	"github.com/bobacgo/kit/web/r/status"
	grpcstatus "google.golang.org/grpc/status"
	"google.golang.org/grpc/codes"
)

// ErrorMessageMap 存储错误码及其多语言信息
var ErrorMessageMap = map[Err]map[string]string{
{{- range $code, $msgs := .Errors }}
	{{ $code }}: {
		"zh": "{{ index $msgs "zh" }}",
		"en": "{{ index $msgs "en" }}",
	},
{{- end }}
}

// New 返回带有错误信息的状态
func New(ctx context.Context, code Err) *status.Status {
	return status.New(int32(code), GetErrorMessage(ctx, code))
}

// Status grpc status 返回带有错误信息的状态
func Status(ctx context.Context, code Err) error {
	return grpcstatus.New(codes.Code(code), GetErrorMessage(ctx, code)).Err()
}

// GetErrorMessage 获取错误信息
func GetErrorMessage(ctx context.Context, code Err) string {
	// 从context中获取语言设置
	lang := "zh"
	if v := ctx.Value("lang"); v != nil {
		if s, ok := v.(string); ok {
			lang = s
		}
	}

	if translations, exists := ErrorMessageMap[code]; exists {
		if msg, ok := translations[lang]; ok {
			return msg
		}
		return translations["zh"] // 默认返回中文
	}
	return "未知错误"
}
`

type ErrorData struct {
	Package string
	Errors  map[int32]map[string]string
}

// go run ./cmd/errgen/main.go user
func main() {
	// 从命令行参数获取模块名
	if len(os.Args) < 2 {
		fmt.Println("请指定要处理的模块名称，例如: go run ./cmd/errgen/main.go user")
		os.Exit(1)
	}
	targetModule := os.Args[1]

	// 获取proto目录下的所有子目录作为模块
	protoDir := "proto"
	entries, err := os.ReadDir(protoDir)
	if err != nil {
		fmt.Printf("Error reading proto directory: %v\n", err)
		return
	}

	// 遍历处理每个模块目录
	for _, entry := range entries {
		// 跳过非目录和third_party目录
		if !entry.IsDir() || entry.Name() == "third_party" {
			continue
		}
		moduleName := entry.Name()

		// 只处理指定的模块
		if moduleName != targetModule {
			continue
		}

		// 自动推导文件路径
		protoPath := filepath.Join("proto", moduleName)

		// 获取版本目录
		versions, err := os.ReadDir(protoPath)
		if err != nil {
			fmt.Printf("Error reading proto directory: %v\n", err)
			os.Exit(1)
		}

		// 检查是否有版本目录
		if len(versions) == 0 {
			fmt.Printf("No version directories found in %s\n", protoPath)
			continue
		}

		// 递归查找所有版本目录中的error.proto文件
		for _, version := range versions {
			if !version.IsDir() {
				continue
			}

			// 查找*_error.proto文件
			files, err := filepath.Glob(filepath.Join(protoPath, version.Name(), "*_error.proto"))
			if err != nil {
				fmt.Printf("Error finding error proto files in version %s: %v\n", version.Name(), err)
				continue
			}
			if len(files) == 0 {
				fmt.Printf("No error proto files found in version %s\n", version.Name())
				continue
			}

			// 处理每个找到的error proto文件
			for _, inputFile := range files {

				// 检查proto文件是否存在
				if _, err := os.Stat(inputFile); os.IsNotExist(err) {
					fmt.Printf("Error proto file not found in version %s: %s\n", version.Name(), inputFile)
					continue
				}

				// 读取proto文件内容以获取go_package
				protoContent, err := os.ReadFile(inputFile)
				if err != nil {
					fmt.Printf("Error reading proto file in version %s: %v\n", version.Name(), err)
					continue
				}

				// 解析go_package
				goPackageRegex := regexp.MustCompile(`option\s+go_package\s*=\s*"([^"]+)";`)
				matches := goPackageRegex.FindSubmatch(protoContent)
				if len(matches) < 2 {
					fmt.Printf("go_package option not found in proto file for version %s\n", version.Name())
					continue
				}

				// 解析go_package路径
				goPackage := strings.TrimPrefix(string(matches[1]), "./")

				// 使用go_package来确定输出路径
				outputFile := filepath.Join("gen/go", goPackage, "error_message.gen.go")

				// 从go_package中提取包名
				pkgName := filepath.Base(goPackage)

				// 解析proto文件
				errors, err := parseProtoFile(inputFile)
				if err != nil {
					fmt.Printf("Error parsing proto file in version %s: %v\n", version.Name(), err)
					continue
				}

				// 生成Go文件
				if err := generateGoFile(outputFile, pkgName, errors); err != nil {
					fmt.Printf("Error generating Go file for version %s: %v\n", version.Name(), err)
					continue
				}

				fmt.Printf("Successfully generated error messages for module %s version %s\n", moduleName, version.Name())
			}
		}
	}
}

func parseProtoFile(filename string) (map[int32]map[string]string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// 正则匹配注释和错误码
	zhRegex := regexp.MustCompile(`//\s*zh:\s*(.+)`)
	enRegex := regexp.MustCompile(`//\s*en:\s*(.+)`)
	codeRegex := regexp.MustCompile(`(\w+)\s*=\s*(\d+);`)

	errors := make(map[int32]map[string]string)
	scanner := bufio.NewScanner(file)
	var zhText, enText string

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// 匹配中文注释
		if matches := zhRegex.FindStringSubmatch(line); matches != nil {
			zhText = matches[1]
			continue
		}

		// 匹配英文注释
		if matches := enRegex.FindStringSubmatch(line); matches != nil {
			enText = matches[1]
			continue
		}

		// 匹配错误码
		if matches := codeRegex.FindStringSubmatch(line); matches != nil {
			code, _ := strconv.ParseInt(matches[2], 10, 32)
			// 对于错误码0不输出警告，其他非6位数的错误码才输出警告
			if code != 0 && len(matches[2]) != 8 {
				fmt.Printf("Warning: Error code %s is not a 6-digit number in line: %s\n", matches[2], line)
			}

			// 只有当同时具有中英文注释时才生成错误信息
			if zhText != "" && enText != "" {
				errors[int32(code)] = map[string]string{
					"zh": zhText,
					"en": enText,
				}
			}
			// 清空注释缓存
			zhText, enText = "", ""
		}
	}

	return errors, scanner.Err()
}

func generateGoFile(outputFile, pkgName string, errors map[int32]map[string]string) error {
	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}

	// 解析模板
	tmpl, err := template.New("error_message").Parse(templateText)
	if err != nil {
		return err
	}

	// 创建输出文件
	output, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer output.Close()

	// 生成代码
	data := ErrorData{
		Package: pkgName,
		Errors:  errors,
	}

	return tmpl.Execute(output, data)
}
